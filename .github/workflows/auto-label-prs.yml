name: Auto-label PRs
on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Label based on PR type
        uses: actions/github-script@v6
        with:
          script: |
            const body = (context.payload.pull_request && context.payload.pull_request.body) || '';
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const currentLabels = (context.payload.pull_request.labels || []).map(label => label.name);
            const desiredLabels = new Set();
            const managedLabels = new Set([
              'bug-fix',
              'feature',
              'enhancement',
              'documentation',
              'refactoring',
              'ready-for-review',
              'work-in-progress',
              'tested',
              'docs-updated'
            ]);

            const typeMappings = [
              { marker: '- [x] Bug fix', label: 'bug-fix' },
              { marker: '- [x] New feature', label: 'feature' },
              { marker: '- [x] Enhancement', label: 'enhancement' },
              { marker: '- [x] Documentation update', label: 'documentation' },
              { marker: '- [x] Code refactoring', label: 'refactoring' }
            ];

            for (const { marker, label } of typeMappings) {
              if (body.includes(marker)) {
                desiredLabels.add(label);
              }
            }

            const checklistMatch = body.match(/## Checklist([\s\S]*?)(##|$)/i);
            const checklistSection = checklistMatch ? checklistMatch[1] : '';
            const checklistItems = checklistSection.match(/- \[[ x]\] .+/g) || [];
            const uncheckedChecklist = checklistItems.filter(item => item.startsWith('- [ ]'));

            if (checklistItems.length && uncheckedChecklist.length === 0) {
              desiredLabels.add('ready-for-review');
            } else {
              desiredLabels.add('work-in-progress');
            }

            if (body.includes('- [x] All new and existing tests pass')) {
              desiredLabels.add('tested');
            }

            if (body.includes('- [x] I have updated the documentation accordingly')) {
              desiredLabels.add('docs-updated');
            }

            const labelsToAdd = Array.from(desiredLabels).filter(label => !currentLabels.includes(label));
            const labelsToRemove = currentLabels.filter(label => managedLabels.has(label) && !desiredLabels.has(label));

            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
            }

            if (labelsToAdd.length) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: labelsToAdd });
            }
