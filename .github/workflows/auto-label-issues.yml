name: Auto-label Issues
on:
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Label based on issue content
        uses: actions/github-script@v6
        with:
          script: |
            const issue = context.payload.issue || {};
            const body = issue.body || '';
            const title = issue.title || '';
            const bodyLower = body.toLowerCase();
            const titleLower = title.toLowerCase();
            const { owner, repo } = context.repo;
            const issueNumber = issue.number;
            const currentLabels = (issue.labels || []).map(label => label.name);
            const managedLabelKeys = [
              'bug',
              'enhancement',
              'documentation',
              'browser:chrome',
              'browser:safari',
              'browser:firefox',
              'browser:edge',
              'os:windows',
              'os:macos',
              'os:linux',
              'priority:high',
              'needs-triage'
            ];
            const desiredLabels = new Set();
            const fetchExistingLabels = async () => {
              const all = await github.paginate(github.rest.issues.listLabelsForRepo, {
                owner,
                repo,
                per_page: 100
              });
              const map = new Map();
              for (const label of all) {
                map.set(label.name.toLowerCase(), label.name);
              }
              return map;
            };
            const labelNameMap = await fetchExistingLabels();
            const resolveLabel = name => labelNameMap.get(name.toLowerCase()) || name;
            const managedLabels = new Set(managedLabelKeys.map(resolveLabel));
            const containsAny = (text, keywords) => keywords.some(keyword => text.includes(keyword));
            const extractSection = headingPrefix => {
              const pattern = new RegExp(`##\\s*${headingPrefix}[^\\n]*\\n([\\s\\S]*?)(?=\\n##\\s|$)`, 'i');
              const match = body.match(pattern);
              return match ? match[1].trim() : '';
            };

            const stepsSection = extractSection('Steps to Reproduce');
            const actualSection = extractSection('Actual Behavior');
            const environmentSection = extractSection('Environment');

            const hasNonPlaceholderSteps = (() => {
              if (!stepsSection) return false;
              const sanitized = stepsSection.replace(/\s+/g, ' ').trim();
              if (!sanitized) return false;
              const placeholderTokens = ["'...'", "'....'", '...'];
              const stillPlaceholder = placeholderTokens.some(token => sanitized.includes(token)) || /See error/i.test(sanitized);
              return !stillPlaceholder;
            })();

            const bugKeywords = ['bug', 'error', 'crash', 'exception', 'stack trace', 'fails', 'broken'];
            if (hasNonPlaceholderSteps || containsAny(titleLower, bugKeywords) || containsAny(bodyLower, bugKeywords) || /unexpected/i.test(actualSection)) {
              desiredLabels.add(resolveLabel('bug'));
            }

            const enhancementKeywords = ['enhancement', 'feature', 'improv', 'overhaul', 'optimiz', 'ux', 'ui', 'design', 'refactor', 'clean up', 'visual'];
            if (containsAny(titleLower, enhancementKeywords) || containsAny(bodyLower, enhancementKeywords)) {
              desiredLabels.add(resolveLabel('enhancement'));
            }

            const documentationKeywords = ['documentation', 'docs', 'readme', 'guide', 'manual'];
            if (containsAny(titleLower, documentationKeywords) || containsAny(bodyLower, documentationKeywords)) {
              desiredLabels.add(resolveLabel('documentation'));
            }

            const normalizeValue = value => value.toLowerCase();
            const hasRealValue = value => value && value.trim() && !/\[e\.g\./i.test(value) && !value.includes('...');

            if (environmentSection) {
              const lines = environmentSection.split('\n').map(line => line.trim()).filter(Boolean);
              for (const line of lines) {
                const parts = line.split(':');
                if (parts.length < 2) continue;
                const rawValue = parts.slice(1).join(':').trim();
                if (!hasRealValue(rawValue)) continue;
                const value = normalizeValue(rawValue);
                if (value.includes('chrome')) desiredLabels.add(resolveLabel('browser:chrome'));
                if (value.includes('safari')) desiredLabels.add(resolveLabel('browser:safari'));
                if (value.includes('firefox')) desiredLabels.add(resolveLabel('browser:firefox'));
                if (value.includes('edge')) desiredLabels.add(resolveLabel('browser:edge'));
                if (value.includes('window')) desiredLabels.add(resolveLabel('os:windows'));
                if (value.includes('mac')) desiredLabels.add(resolveLabel('os:macos'));
                if (value.includes('linux') || value.includes('ubuntu')) desiredLabels.add(resolveLabel('os:linux'));
              }
            }

            const priorityKeywords = ['critical', 'urgent', 'blocker', 'severity'];
            if (containsAny(titleLower, priorityKeywords) || containsAny(bodyLower, priorityKeywords)) {
              desiredLabels.add(resolveLabel('priority:high'));
            }

            const action = context.payload.action;
            const classificationLabels = new Set(['bug', 'enhancement', 'documentation', 'priority:high'].map(resolveLabel));
            const hasAutoClassification = Array.from(desiredLabels).some(label => classificationLabels.has(label));
            if (!hasAutoClassification && (action === 'opened' || currentLabels.includes(resolveLabel('needs-triage')))) {
              desiredLabels.add(resolveLabel('needs-triage'));
            }

            const labelsToAdd = Array.from(desiredLabels).filter(label => !currentLabels.includes(label));
            const labelsToRemove = currentLabels.filter(label => managedLabels.has(label) && !desiredLabels.has(label));

            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: label });
              } catch (error) {
                // Ignore if label was already removed manually
              }
            }

            if (labelsToAdd.length) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: labelsToAdd });
            }
